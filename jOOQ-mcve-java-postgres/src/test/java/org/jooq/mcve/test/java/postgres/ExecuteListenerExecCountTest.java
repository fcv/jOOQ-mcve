package org.jooq.mcve.test.java.postgres;

import org.flywaydb.core.Flyway;
import org.jooq.DSLContext;
import org.jooq.ExecuteContext;
import org.jooq.ExecuteListener;
import org.jooq.Query;
import org.jooq.ResultQuery;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.jooq.mcve.java.postgres.tables.records.TestRecord;
import org.jooq.tools.JooqLogger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.utility.ResourceReaper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

import static org.jooq.mcve.java.postgres.Tables.TEST;
import static org.junit.Assert.assertEquals;

public class ExecuteListenerExecCountTest {

    static JooqLogger log = JooqLogger.getLogger(ExecuteListenerExecCountTest.class);
    static PostgreSQLContainer db;
    static Connection connection;
    static DSLContext ctx;
    static CounterExecuteListener counterExecuteListener = new CounterExecuteListener();

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("db.url") == null) {
            db = new PostgreSQLContainer("postgres:15.3")
                     .withUsername("postgres")
                     .withDatabaseName("postgres")
                     .withPassword("postgres");
            db.start();
            System.setProperty("db.url", db.getJdbcUrl());
            System.setProperty("db.username", db.getUsername());
            System.setProperty("db.password", db.getPassword());
        }

        Properties properties = new Properties();
        properties.setProperty("username", "postgres");
        properties.setProperty("password", "postgres");

        log.info("Connecting");
        connection = DriverManager.getConnection(
            System.getProperty("db.url"),
            System.getProperty("db.username"),
            System.getProperty("db.password")
        );

        ctx = DSL.using(connection, SQLDialect.POSTGRES);
        ctx.configuration().set(counterExecuteListener);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }

        if (db != null) {
            Flyway
                .configure()
                .dataSource(
                    System.getProperty("db.url"),
                    System.getProperty("db.username"),
                    System.getProperty("db.password"))
                .load()
                .migrate();
            log.info("Finished migration");
        }
    }

    static class CounterExecuteListener implements ExecuteListener {
        int executeEndCounter;
        int fetchEndCounter;
        int endCounter;

        @Override
        public void executeEnd(ExecuteContext ctx) {
            executeEndCounter ++;
        }

        @Override
        public void fetchEnd(ExecuteContext ctx) {
            fetchEndCounter ++;
        }
        public void end(ExecuteContext ctx) {
            endCounter ++;
        }

        public void reset() {
            executeEndCounter = 0;
            fetchEndCounter = 0;
            endCounter = 0;
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(TEST).execute();
    }

    @Before
    public void resetQueryTracker() {
        counterExecuteListener.reset();
    }

    @After
    public void after() throws Exception {
    }

    @Test
    public void dslSelect() {
        ResultQuery<TestRecord> resultQuery = ctx.selectFrom(TEST);
        resultQuery.fetch();

        assertEquals("counterExecuteListener.executeEnd should be executed exactly once", 1, counterExecuteListener.executeEndCounter);
        assertEquals("counterExecuteListener.fetchEnd should be executed exactly once", 1, counterExecuteListener.fetchEndCounter);
        assertEquals("counterExecuteListener.end should be executed exactly once", 1, counterExecuteListener.endCounter);
    }

    @Test
    public void plainSelect() {
        ResultQuery<?> resultQuery = ctx.resultQuery("SELECT * FROM mcve.test");
        resultQuery.fetch();

        assertEquals("counterExecuteListener.executeEnd should be executed exactly once", 1, counterExecuteListener.executeEndCounter);
        assertEquals("counterExecuteListener.fetchEnd should be executed exactly once", 1, counterExecuteListener.fetchEndCounter);
        assertEquals("counterExecuteListener.end should be executed exactly once", 1, counterExecuteListener.endCounter);
    }

    @Test
    public void dslUpdateWithReturningClause() {
        ResultQuery<?> resultQuery = ctx.update(TEST).set(TEST.CD, 1).returning(TEST.CD);
        resultQuery.fetch();

        assertEquals("counterExecuteListener.executeEnd should be executed exactly once", 1, counterExecuteListener.executeEndCounter);
        assertEquals("counterExecuteListener.fetchEnd should be executed exactly once", 1, counterExecuteListener.fetchEndCounter);
        assertEquals("counterExecuteListener.end should be executed exactly once", 1, counterExecuteListener.endCounter);
    }

    @Test
    public void plainUpdateWithReturningClause() {
        ResultQuery<?> resultQuery = ctx.resultQuery("UPDATE mcve.test SET cd = 1 RETURNING cd");
        resultQuery.fetch();

        assertEquals("counterExecuteListener.executeEnd should be executed exactly once", 1, counterExecuteListener.executeEndCounter);
        assertEquals("counterExecuteListener.fetchEnd should be executed exactly once", 1, counterExecuteListener.fetchEndCounter);
        assertEquals("counterExecuteListener.end should be executed exactly once", 1, counterExecuteListener.endCounter);
    }

    @Test
    public void dslUpdate() {
        Query resultQuery = ctx.update(TEST).set(TEST.CD, 1);
        resultQuery.execute();

        assertEquals(1, counterExecuteListener.executeEndCounter);
        assertEquals(0, counterExecuteListener.fetchEndCounter);
        assertEquals(1, counterExecuteListener.endCounter);
    }
}
